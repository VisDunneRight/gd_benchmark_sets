
<!doctype html>
<html>
<head>
    <title>Graph Benchmark Datasets</title>
    <link rel="stylesheet" href="sidebar.css">
    <meta name="description" content="Graph Benchmark Datasets">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe" crossorigin="anonymous"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>

    <style>
        #named-list {
            display: flex;
            flex-direction: column;
            font-size: small;
            padding-bottom: 5%;
        }

        .small-text {
            font-size: small;
        }

        .footer{
            /* position: fixed; */
            bottom: 0;
            width: 100%;
            height: 2.5rem;
            background-color: white;
            text-align: center;
            padding-top: 1%;
        }
        .scroll-offset{
            scroll-margin-top: 2em;
        }

        blockquote {
            margin-left: 40px;
            margin-right: 40px;
        }
    </style>
</head>
<body>
    <header class="navbar navbar-expand-lg navbar-dark bd-navbar sticky-top">
        <nav class="container-xxl bd-gutter flex-wrap flex-lg-nowrap" aria-label="Main navigation">
          <div class="bd-navbar-toggle">
            <button class="navbar-toggler p-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#bdSidebar" aria-controls="bdSidebar" aria-label="Toggle docs navigation">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="bi" fill="currentColor" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M2.5 11.5A.5.5 0 0 1 3 11h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 3h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path>
            </svg>
              <span class="d-none fs-6 pe-1">Browse Datasets</span>
            </button>
          </div>
        </nav>
    </header>
    <div class="container-xxl bd-gutter mt-3 my-md-4 bd-layout">
        <aside class="bd-sidebar">
            <div class="offcanvas-lg offcanvas-start" tabindex="-1" id="bdSidebar" aria-labelledby="bdSidebarOffcanvasLabel">
              <div class="offcanvas-header border-bottom">
                <h5 class="offcanvas-title" id="bdSidebarOffcanvasLabel">Browse Datasets</h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#bdSidebar"></button>
              </div>
      
              <div class="offcanvas-body">
                <nav class="bd-links w-100" id="bd-docs-nav" aria-label="Docs navigation">
                    <ul class="bd-links-nav list-unstyled mb-0 pb-3 pb-md-2 pe-lg-2">
                        <div id="db-nav-list"></div>
                    </ul>
                </nav>
              </div>
            </div>
          </aside>
    <div class="container overflow-hidden">
        <h1 class="" style="margin-top: 5%">Graph Benchmark Datasets</h1>
        <div class="row">
          <!-- <div class="col-sm-2">
            navbar navbar navbar menu menu menu <br> <br>
            Usage instructions, cite us at [bibtex]
          </div> -->
          <div class="col-lg-10 bg-light">
            The following is a list of benchmark datasets for testing graph layout algorithms. <br>
            Click on the names of the collections to expand them and access information about their contents and a list of papers using them.<br><br>
            If you find our work useful for your research, consider citing our paper as well as the linked "Origin Paper" for each dataset used:
            <br><br>

            <pre style="color: palevioletred;">
    @article{knuth:1984,
            title={Literate Programming},
            author={Donald E. Knuth},
            journal={The Computer Journal}
        }
                </pre>
            <div id="named-list" data-bs-spy="scroll"  data-bs-target="db-nav-list" data-bs-offset="20" tabindex="0">
            </div>
          </div>
        </div>
      </div>
    </div>
      <div class="footer">
        
      </div>
</body>
<script>
    function add_simple_field(entry, field_name, div, name = ""){
        if (entry[field_name] != "" && entry[field_name] != undefined){
            let title = name === "" ? field_name : name;
            div.append("div").html("<b>" + title + ": </b>" + urlify(entry[field_name]))
        }
    }

    function urlify(text) {
        var urlRegex = /(([a-z]+:\/\/)?(([a-z0-9\-]+\.)+([a-z]{2}|aero|arpa|biz|com|coop|edu|gov|info|int|jobs|mil|museum|name|nato|net|org|pro|travel|local|internal))(:[0-9]{1,5})?(\/[a-z0-9_\-\.~]+)*(\/([a-z0-9_\-\.]*)(\?[a-z0-9+_\-\.%=&amp;]*)?)?(#[a-zA-Z0-9!$&'()*+.=-_~:@/?]*)?)(\s+|$)/gi;
        return text.replace(urlRegex, function(url) {
            return '<a href="' + url + '">' + url + '</a>';
        })
    }

    function doify(text){
        if (text == "" || text == undefined) return text;
        if (text.includes("https")) return (text);
        else return ("https://doi.org/" + text);
    }

    function getTextAfterBody(input) {
        const lines = input.split('\n');
        let emptyLineCount = 0;
        let text = '';

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            if (line === '# Body') {
                text = lines.slice(i + 1).join('\n');
            } 
        }
        
        return text;
    }

    function name_cleanup(name){
        return name.replace("(", "").replace(")", "").replace(" ", "_").replace(".", "").replace("'", "").replace("&", "").replaceAll(" ", "")
    }

    function make_sparkline_visualization(entry, row){
        if (entry["sparkline data"] == "" || entry["sparkline data"] == undefined) {
            row.append("div")
                .attr("class", "col")
            return;
        };

        // parse json
        let parsed = JSON.parse(entry["sparkline data"].replaceAll("'", '"'))
        console.log(parsed)

        let data, color;
        if (parsed.num_nodes){
            data = parsed.num_nodes;
            color = "#69b3a2"
        } else {
            data = parsed.node_degree;
            color = "#404080"
        }

        //Sparklines
        const sparkHeight = 20;
        const sparkWidth = 100;
        const step = sparkWidth/data.length;
        const min = parsed.min;
        const max = parsed.max;

        let gSpark = row.append("div")
            .attr("class", "col-4")
            .attr("style", "display:flex;align-items:center;")

        let svg = gSpark.append("svg")
        .attr("width", sparkWidth)
        .attr("height", sparkHeight)
        // .append("g")

        let minMax = gSpark.append("div")
        .attr("class", "col")
        .attr("style","display:flex; align-items:left;");

        minMax.append("img")
        .attr("src","min.svg" )
        .attr("width", 20)
        .attr("height", 20)
        .style("padding-left", "5px")

        minMax.append("Span")
        .text(min)
        .attr("style", "padding-right:5px; padding-left:5px");

        let divmax = gSpark.append("div")
        .attr("class", "col")
        .attr("style","display:flex; align-items:left;");

        divmax.append("img")
        .attr("src","max.svg")
        .attr("width", 20)
        .attr("height", 20)
        .style("padding-left", "5px")

        divmax.append("Span")
        .text(max)
        .attr("style", "padding-right:5px; padding-left:5px");

        let y = d3.scaleLinear()
        .domain([0, d3.max(data)])
        .range([sparkHeight, 0]);
        
        svg.selectAll("bar")
        .data(data)
        .enter()
        .append("rect")
            .attr("x", function(d,i) { return i*step; })
            .attr("y", function(d) { return y(d); })
            .attr("width", step)
            .attr("height", function(d) { return sparkHeight - y(d); })
            .attr("fill", color)
        .append("title")
        .text(function(d){return d});

        svg.append("line")
            .attr("x1", 0)
            .attr("y1", y(0))
            .attr("x2", sparkWidth)
            .attr("y2", y(0))
            .attr("stroke", "#333")
            .attr("stroke-width", 4);
    }

    async function add_entry_row(named_list_dom, db_nav_list, paper_data, entry){
        // console.log(entry["Type of Collection"])

        // console.log(entry)
        //Fills the navs on the left sid        

        db_nav_list.append("li")
            .append("a")
            .attr("href", "#moveTo" + name_cleanup(entry["Name"]))
            .attr("class", "bd-links-link d-inline-block rounded")
            .text(entry["Name"])


        //Fills the content for each dataset
        let row = named_list_dom.append("div")
            .attr("class", "row scroll-offset")
            .attr("id" ,"moveTo" + name_cleanup(entry["Name"]))

        row.append("div")
            .attr("class", "col")
            .append("a")
            .style("font-weight", "bold")
            .html("<u>" + entry["Name"] + "</u>")
            .attr("data-bs-toggle", "collapse")
            .attr("href", "#inforow_" + name_cleanup(entry["Name"]))
            .attr("aria-expanded", "false")
            .attr("aria-controls", "inforow_" + name_cleanup(entry["Name"]))
            .style("color", "black")
            .attr("role", "button")

        make_sparkline_visualization(entry, row)

        //Pills for the type of data it is
        let gfeatures = row.append("div")
            .attr("class", "col")
        
        for (let graph_feature of entry["graph features handled"].split(",")){
            if (graph_feature.charAt(0) == ' '){
                graph_feature = graph_feature.substring(1)
            }
            gfeatures.append("div")
                .attr("class", "rounded-pill badge")
                .style("margin", "2px")
                .style("background-color", graph_feature_tags_colors[graph_feature_tags.indexOf(graph_feature)%graph_feature_tags_colors.length])
                .text(graph_feature)
        }

        let infocontainer = row.append("div")
            .attr("class", "container collapse")
            .attr("id", "inforow_" + name_cleanup(entry["Name"]))
            .style("padding", "2%")

        let inforow = infocontainer.append("div")
            .append("div")
            .attr("class", "card card-body")
            .append("div")
            .attr("class", "col small-text")

        add_simple_field(entry, "Originally found at", inforow)
        add_simple_field(entry, "OSF link", inforow, "Link to Data")
        add_simple_field(entry, "Note", inforow)
        add_simple_field(entry, "Number of Files", inforow)
        add_simple_field(entry, "Size", inforow)
        add_simple_field(entry, "Origin Notes", inforow)
        // add_simple_field(entry, "Format", inforow)

        inforow.append("div").html("<b>Origin paper: </b>")
        for (let e of entry["Origin paper plaintext"].split(",")){
            e = e.trim();
            if (e == "") continue;
            let origindoi = (paper_data.find(a => a.Name == e) || {}).DOI
            if (origindoi != undefined && origindoi != "") 
                inforow.append("div").html('<a href="' + doify(origindoi) + '">' + "[link]" + '</a> &nbsp;' + e)
            else inforow.append("div").html(e)
        }

        inforow.append("div").html("<b>Usage examples: </b>")

        for (let i in entry["Related to Literature - Algorithm (Dataset tag relations) 1"].split(",")){
            let e = entry["Related to Literature - Algorithm (Dataset tag relations) 1"].split(",")[i].split("(")[0].trim()
            let entryrow = inforow.append("div").attr("class", "row")

            if (e != "") {
                let doi = (paper_data.find(a => a.Name == e) || {}).DOI
                let link;
                if (doi != undefined && doi != "") link = '<a href="' + doify(doi) + '">[link]</a>'
                else link = ""

                entryrow.append("div")
                    .attr("class", "col-8")
                    .html(link + " &nbsp; " + urlify(e))

                let tagrow = entryrow.append("div").attr("class", "col-4")

                if (paper_data.find(a => a.Name == e)){
                    let feature_collection = (paper_data.find(a => a.Name == e) || {})["Graph feature"].split(",")
                    
                    for (let graph_feature of feature_collection){
                        graph_feature = graph_feature.trim().toLowerCase()
                        tagrow.append("div")
                            .attr("class", "rounded-pill badge")
                            .style("margin", "2px")
                            .style("background-color", graph_feature_tags_colors[graph_feature_tags.indexOf(graph_feature)%graph_feature_tags_colors.length])
                            .text(graph_feature)
                    }
                }
            }
        }

        inforow.append("br")

        // DRAW REST OF THE PAGE
        let otherinfo = ""
        try{
            let otherinfo = await fetch("notion_data/Benchmark datasets 64e0439269f9497799025562a4087ce1/" + entry["Name"].replace(".", "") + " " + entry["Page id"] + ".md")
            otherinfo = await otherinfo.text()
            var converter = new showdown.Converter();
            
            otherinfo = getTextAfterBody(otherinfo);
            
            for (let line of otherinfo.split("\n")){
                if (line[0] == "!") {
                    let img = line.split("(")[1].slice(0, -1)
                    inforow.append("div")
                        .style("text-align", "center")
                        .append("img")
                        .attr("src", "notion_data/Benchmark datasets 64e0439269f9497799025562a4087ce1/" + img)
                        .attr("width", "80%")
                } else if (line.includes("STOP RENDERING")){
                     break;
                } else inforow.append("div").html(converter.makeHtml(line))
                
            }

        } catch (e){
            console.log(e)
        }

        inforow.append("br")
        // break;

        row.append("hr")
            .style("margin-left", "2.5%")
            .style("width", "95%")
            .style("margin-top", "5px")
            .style("margin-bottom", "5px")
    }

    graph_feature_tags = []
    graph_feature_tags_colors = ["#9B9A97", "#64473A", "#D9730D", "#DFAB01", "#0F7B6C", "#0B6E99", "#6940A5", "#AD1A72", "#E03E3E"]

    async function main(){
        let data = await d3.csv("notion_data/Benchmark datasets 64e0439269f9497799025562a4087ce1.csv")
        let paper_data = await d3.csv("notion_data/Literature - Algorithm 12e01bfc60a84007aa7d2d34293e123d.csv")
        let named_list_dom = d3.select("#named-list")
        let db_nav_list = d3.select("#db-nav-list");

        for (let entry of data){
            if (entry["graph features handled"] != "" && entry["graph features handled"] != undefined){
                let tags = entry["graph features handled"].split(",")
                for (let j = 0; j < tags.length; j++){
                    if (tags[j].charAt(0) == ' '){
                        tags[j] = tags[j].substring(1).toLowerCase()
                    }
                    if (!graph_feature_tags.includes(tags[j])){
                        graph_feature_tags.push(tags[j])
                    }
                }
            }
        }
        for (let entry of paper_data){
            let features = (entry["Graph feature"]).split(",")
            for (let feature of features){
                feature = feature.trim().toLowerCase()
                if (!graph_feature_tags.includes(feature)){
                    graph_feature_tags.push(feature)
                }
            }
        }

        for (let entry of data.filter(d => d["Type of Collection"] == "Skip")){
            entry.added = true;
            continue;
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Benchmark datasets")
            .style("margin-top", "10px")

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("p")
            .text("These are collections of graphs that have been frequently used in graph drawing papers. By clicking on each collection name, you can see additional information. We also provide an analysis of the contents of each collection, and a list of papers that use them, their sources, and various types of information.")
            .style("color", "gray")
        
        let benchLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2");

        benchLi
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Benchmark datasets")
        let benchul = benchLi
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")
        
        for (let entry of data.filter(d => d["Type of Collection"] == "Uniform Benchmark")){
            entry.added = true;
            await add_entry_row(named_list_dom, benchul, paper_data, entry)
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Established Network Repositories")
            .style("margin-top", "10px")

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("p")
            .text("The following collections are organized, classified and maintained by other people or institutions. We do not claim any ownership over them, and we do not guarantee that they will be maintained in the future. We provide links to them for convenience, as well as information about which papers use them and what features are contained in the graphs in them.")
            .style("color", "gray")

        let netLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2")
        netLi
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Established Network Repositories")
        let netul = netLi
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")

        for (let entry of data.filter(d => d["Type of Collection"] == "Established Network Repo (No report)")){
            entry.added = true;
            await add_entry_row(named_list_dom, netul, paper_data, entry)
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Aggregate collections")
            .style("margin-top", "10px")

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("p")
            .text("The following collections are aggregates: they share similar sources and similar features/purpose, but come from different sources. ")
            .style("color", "gray")

        let aggLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2")
        aggLi
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Aggregate collections")
        let aggul = aggLi
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")

        for (let entry of data.filter(d => d["Type of Collection"] == "Aggregate collection")){
            entry.added = true;
            await add_entry_row(named_list_dom, aggul, paper_data, entry)
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Single Graphs")
            .style("margin-top", "10px")

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("p")
            .text("The following are not collections, but individual graphs. They are often used as examples in papers, or as test cases for specific features. ")
            .style("color", "gray")

        
        let singleLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2")
        singleLi    
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Single Graphs")
        singleUl = singleLi
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")

        for (let entry of data.filter(d => d["Type of Collection"] == "Single Graph")){
            entry.added = true;
            await add_entry_row(named_list_dom, singleUl, paper_data, entry)
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Lost or Unavailable")
            .style("margin-top", "10px")

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("p")
            .text("The following collections are unavailable, often due to link rot or unmaintained websites. We invite whoever might have access to these collections to contact us so that we can add them to the list, or gather more information about them. ")
            .style("color", "gray")

        
        let lostLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2")
        lostLi    
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Lost or Unavailable")
        let lostUl = lostLi
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")

        for (let entry of data.filter(d => d["Type of Collection"] == "Lost/Unavailable")){
            entry.added = true;
            await add_entry_row(named_list_dom, lostUl, paper_data, entry)
        }

        named_list_dom.append("div")
            .attr("class", "row")
            .append("div")
            .attr("class", "col")
            .append("h3")
            .text("Other")
            .style("margin-top", "10px")

        let otherLi = db_nav_list.append("li")
            .attr("class", "bd-links-group py-2")
        otherLi
            .append("strong")
            .attr("class", "bd-links-heading d-flex w-100 align-items-center fw-semibold")
            .text("Other")
        let otherUl = otherLi 
            .append("ul")
            .attr("class", "list-unstyled fw-normal pb-2 small")

        for (let entry of data.filter(d => d.added != true)){
            entry.added = true;
            await add_entry_row(named_list_dom, otherUl, paper_data, entry)
        }

    }

    main()
   
</script>
</html>
